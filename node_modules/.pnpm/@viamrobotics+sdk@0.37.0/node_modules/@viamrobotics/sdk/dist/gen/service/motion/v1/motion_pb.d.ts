// @generated by protoc-gen-es v1.10.0
// @generated from file service/motion/v1/motion.proto (package viam.service.motion.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Struct, Timestamp } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { GeoGeometry, Geometry, GeoPoint, Pose, PoseInFrame, ResourceName, Transform, WorldState } from "../../../common/v1/common_pb.js";

/**
 * The states that a plan can be in.
 * InProgress if the plan is executing.
 * Stopped if the plan was stopped.
 * Suceeded if the robot reached its destination successfully.
 * Failed if the robot did not reach its destination.
 *
 * @generated from enum viam.service.motion.v1.PlanState
 */
export declare enum PlanState {
  /**
   * @generated from enum value: PLAN_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: PLAN_STATE_IN_PROGRESS = 1;
   */
  IN_PROGRESS = 1,

  /**
   * @generated from enum value: PLAN_STATE_STOPPED = 2;
   */
  STOPPED = 2,

  /**
   * @generated from enum value: PLAN_STATE_SUCCEEDED = 3;
   */
  SUCCEEDED = 3,

  /**
   * @generated from enum value: PLAN_STATE_FAILED = 4;
   */
  FAILED = 4,
}

/**
 * Moves any component on the robot to a specified destination which can be from the reference frame of any other component on the robot.
 *
 * @generated from message viam.service.motion.v1.MoveRequest
 */
export declare class MoveRequest extends Message<MoveRequest> {
  /**
   * Name of the motion service
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Destination to move to, which can a pose in the reference frame of any frame in the robot's frame system
   *
   * @generated from field: viam.common.v1.PoseInFrame destination = 2;
   */
  destination?: PoseInFrame;

  /**
   * Component on the robot to move to the specified destination
   *
   * @generated from field: viam.common.v1.ResourceName component_name = 3;
   */
  componentName?: ResourceName;

  /**
   * Avoid obstacles by specifying their geometries in the world state
   * Augment the frame system of the robot by specifying additional transforms to add to it for the duration of the Move
   *
   * @generated from field: optional viam.common.v1.WorldState world_state = 4;
   */
  worldState?: WorldState;

  /**
   * Constrain the way the robot will move
   *
   * @generated from field: optional viam.service.motion.v1.Constraints constraints = 5;
   */
  constraints?: Constraints;

  /**
   * Additional arguments to the method
   *
   * @generated from field: google.protobuf.Struct extra = 99;
   */
  extra?: Struct;

  constructor(data?: PartialMessage<MoveRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.MoveRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MoveRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MoveRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MoveRequest;

  static equals(a: MoveRequest | PlainMessage<MoveRequest> | undefined, b: MoveRequest | PlainMessage<MoveRequest> | undefined): boolean;
}

/**
 * @generated from message viam.service.motion.v1.MoveResponse
 */
export declare class MoveResponse extends Message<MoveResponse> {
  /**
   * @generated from field: bool success = 1;
   */
  success: boolean;

  constructor(data?: PartialMessage<MoveResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.MoveResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MoveResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MoveResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MoveResponse;

  static equals(a: MoveResponse | PlainMessage<MoveResponse> | undefined, b: MoveResponse | PlainMessage<MoveResponse> | undefined): boolean;
}

/**
 * @generated from message viam.service.motion.v1.MoveOnMapRequest
 */
export declare class MoveOnMapRequest extends Message<MoveOnMapRequest> {
  /**
   * Name of the motion service
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Specify a destination to, which can be any pose with respect to the SLAM map's origin
   *
   * @generated from field: viam.common.v1.Pose destination = 2;
   */
  destination?: Pose;

  /**
   * Component on the robot to move to the specified destination
   *
   * @generated from field: viam.common.v1.ResourceName component_name = 3;
   */
  componentName?: ResourceName;

  /**
   * Name of the slam service from which the SLAM map is requested
   *
   * @generated from field: viam.common.v1.ResourceName slam_service_name = 4;
   */
  slamServiceName?: ResourceName;

  /**
   * Optional set of motion configuration options
   *
   * @generated from field: optional viam.service.motion.v1.MotionConfiguration motion_configuration = 5;
   */
  motionConfiguration?: MotionConfiguration;

  /**
   * Obstacles to be considered for motion planning
   *
   * @generated from field: repeated viam.common.v1.Geometry obstacles = 6;
   */
  obstacles: Geometry[];

  /**
   * Additional arguments to the method
   *
   * @generated from field: google.protobuf.Struct extra = 99;
   */
  extra?: Struct;

  constructor(data?: PartialMessage<MoveOnMapRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.MoveOnMapRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MoveOnMapRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MoveOnMapRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MoveOnMapRequest;

  static equals(a: MoveOnMapRequest | PlainMessage<MoveOnMapRequest> | undefined, b: MoveOnMapRequest | PlainMessage<MoveOnMapRequest> | undefined): boolean;
}

/**
 * @generated from message viam.service.motion.v1.MoveOnMapResponse
 */
export declare class MoveOnMapResponse extends Message<MoveOnMapResponse> {
  /**
   * The unique ID which identifies the execution.
   * Multiple plans will share the same execution_id if they were
   * generated due to replanning.
   *
   * @generated from field: string execution_id = 1;
   */
  executionId: string;

  constructor(data?: PartialMessage<MoveOnMapResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.MoveOnMapResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MoveOnMapResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MoveOnMapResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MoveOnMapResponse;

  static equals(a: MoveOnMapResponse | PlainMessage<MoveOnMapResponse> | undefined, b: MoveOnMapResponse | PlainMessage<MoveOnMapResponse> | undefined): boolean;
}

/**
 * Pairs a vision service with a camera, informing the service about which camera it may use
 *
 * @generated from message viam.service.motion.v1.ObstacleDetector
 */
export declare class ObstacleDetector extends Message<ObstacleDetector> {
  /**
   * @generated from field: viam.common.v1.ResourceName vision_service = 1;
   */
  visionService?: ResourceName;

  /**
   * @generated from field: viam.common.v1.ResourceName camera = 2;
   */
  camera?: ResourceName;

  constructor(data?: PartialMessage<ObstacleDetector>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.ObstacleDetector";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ObstacleDetector;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ObstacleDetector;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ObstacleDetector;

  static equals(a: ObstacleDetector | PlainMessage<ObstacleDetector> | undefined, b: ObstacleDetector | PlainMessage<ObstacleDetector> | undefined): boolean;
}

/**
 * @generated from message viam.service.motion.v1.MotionConfiguration
 */
export declare class MotionConfiguration extends Message<MotionConfiguration> {
  /**
   * The ObstacleDetectors that will be used for transient obstacle avoidance
   *
   * @generated from field: repeated viam.service.motion.v1.ObstacleDetector obstacle_detectors = 1;
   */
  obstacleDetectors: ObstacleDetector[];

  /**
   * Sets the frequency to poll for the position of the robot
   *
   * @generated from field: optional double position_polling_frequency_hz = 2;
   */
  positionPollingFrequencyHz?: number;

  /**
   * Sets the frequency to poll the vision service(s) for new obstacles
   *
   * @generated from field: optional double obstacle_polling_frequency_hz = 3;
   */
  obstaclePollingFrequencyHz?: number;

  /**
   * Sets the distance in meters that a robot is allowed to deviate from the motion plan
   *
   * @generated from field: optional double plan_deviation_m = 4;
   */
  planDeviationM?: number;

  /**
   * Optional linear velocity to target when moving
   *
   * @generated from field: optional double linear_m_per_sec = 5;
   */
  linearMPerSec?: number;

  /**
   * Optional angular velocity to target when turning
   *
   * @generated from field: optional double angular_degs_per_sec = 6;
   */
  angularDegsPerSec?: number;

  constructor(data?: PartialMessage<MotionConfiguration>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.MotionConfiguration";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MotionConfiguration;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MotionConfiguration;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MotionConfiguration;

  static equals(a: MotionConfiguration | PlainMessage<MotionConfiguration> | undefined, b: MotionConfiguration | PlainMessage<MotionConfiguration> | undefined): boolean;
}

/**
 * @generated from message viam.service.motion.v1.MoveOnGlobeRequest
 */
export declare class MoveOnGlobeRequest extends Message<MoveOnGlobeRequest> {
  /**
   * Name of the motion service
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Destination, encoded as a GeoPoint
   *
   * @generated from field: viam.common.v1.GeoPoint destination = 2;
   */
  destination?: GeoPoint;

  /**
   * Optional compass heading to achieve at the destination, in degrees [0-360)
   *
   * @generated from field: optional double heading = 3;
   */
  heading?: number;

  /**
   * Component on the robot to move to the specified destination
   *
   * @generated from field: viam.common.v1.ResourceName component_name = 4;
   */
  componentName?: ResourceName;

  /**
   * Name of the movement sensor which will be used to check robot location
   *
   * @generated from field: viam.common.v1.ResourceName movement_sensor_name = 5;
   */
  movementSensorName?: ResourceName;

  /**
   * Obstacles to be considered for motion planning
   *
   * @generated from field: repeated viam.common.v1.GeoGeometry obstacles = 6;
   */
  obstacles: GeoGeometry[];

  /**
   * Optional set of motion configuration options
   *
   * @generated from field: optional viam.service.motion.v1.MotionConfiguration motion_configuration = 7;
   */
  motionConfiguration?: MotionConfiguration;

  /**
   * Set of obstacles which the robot must remain within while navigating
   *
   * @generated from field: repeated viam.common.v1.GeoGeometry bounding_regions = 8;
   */
  boundingRegions: GeoGeometry[];

  /**
   * Additional arguments to the method
   *
   * @generated from field: google.protobuf.Struct extra = 99;
   */
  extra?: Struct;

  constructor(data?: PartialMessage<MoveOnGlobeRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.MoveOnGlobeRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MoveOnGlobeRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MoveOnGlobeRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MoveOnGlobeRequest;

  static equals(a: MoveOnGlobeRequest | PlainMessage<MoveOnGlobeRequest> | undefined, b: MoveOnGlobeRequest | PlainMessage<MoveOnGlobeRequest> | undefined): boolean;
}

/**
 * @generated from message viam.service.motion.v1.MoveOnGlobeResponse
 */
export declare class MoveOnGlobeResponse extends Message<MoveOnGlobeResponse> {
  /**
   * The unique ID which identifies the execution.
   * Multiple plans will share the same execution_id if they were
   * generated due to replanning.
   *
   * @generated from field: string execution_id = 1;
   */
  executionId: string;

  constructor(data?: PartialMessage<MoveOnGlobeResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.MoveOnGlobeResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MoveOnGlobeResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MoveOnGlobeResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MoveOnGlobeResponse;

  static equals(a: MoveOnGlobeResponse | PlainMessage<MoveOnGlobeResponse> | undefined, b: MoveOnGlobeResponse | PlainMessage<MoveOnGlobeResponse> | undefined): boolean;
}

/**
 * @generated from message viam.service.motion.v1.GetPoseRequest
 */
export declare class GetPoseRequest extends Message<GetPoseRequest> {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * the component whose pose is being requested
   *
   * @generated from field: viam.common.v1.ResourceName component_name = 2;
   */
  componentName?: ResourceName;

  /**
   * the reference frame in which the component's pose
   * should be provided, if unset this defaults
   * to the "world" reference frame
   *
   * @generated from field: string destination_frame = 3;
   */
  destinationFrame: string;

  /**
   * pose information on any additional reference frames that are needed
   * to compute the component's pose
   *
   * @generated from field: repeated viam.common.v1.Transform supplemental_transforms = 4;
   */
  supplementalTransforms: Transform[];

  /**
   * Additional arguments to the method
   *
   * @generated from field: google.protobuf.Struct extra = 99;
   */
  extra?: Struct;

  constructor(data?: PartialMessage<GetPoseRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.GetPoseRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPoseRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPoseRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPoseRequest;

  static equals(a: GetPoseRequest | PlainMessage<GetPoseRequest> | undefined, b: GetPoseRequest | PlainMessage<GetPoseRequest> | undefined): boolean;
}

/**
 * @generated from message viam.service.motion.v1.GetPoseResponse
 */
export declare class GetPoseResponse extends Message<GetPoseResponse> {
  /**
   * @generated from field: viam.common.v1.PoseInFrame pose = 1;
   */
  pose?: PoseInFrame;

  constructor(data?: PartialMessage<GetPoseResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.GetPoseResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPoseResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPoseResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPoseResponse;

  static equals(a: GetPoseResponse | PlainMessage<GetPoseResponse> | undefined, b: GetPoseResponse | PlainMessage<GetPoseResponse> | undefined): boolean;
}

/**
 * @generated from message viam.service.motion.v1.StopPlanRequest
 */
export declare class StopPlanRequest extends Message<StopPlanRequest> {
  /**
   * The name of the motion service
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The component of the currently executing plan to stop
   *
   * @generated from field: viam.common.v1.ResourceName component_name = 2;
   */
  componentName?: ResourceName;

  /**
   * Additional arguments to the method
   *
   * @generated from field: google.protobuf.Struct extra = 99;
   */
  extra?: Struct;

  constructor(data?: PartialMessage<StopPlanRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.StopPlanRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StopPlanRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StopPlanRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StopPlanRequest;

  static equals(a: StopPlanRequest | PlainMessage<StopPlanRequest> | undefined, b: StopPlanRequest | PlainMessage<StopPlanRequest> | undefined): boolean;
}

/**
 * @generated from message viam.service.motion.v1.StopPlanResponse
 */
export declare class StopPlanResponse extends Message<StopPlanResponse> {
  constructor(data?: PartialMessage<StopPlanResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.StopPlanResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StopPlanResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StopPlanResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StopPlanResponse;

  static equals(a: StopPlanResponse | PlainMessage<StopPlanResponse> | undefined, b: StopPlanResponse | PlainMessage<StopPlanResponse> | undefined): boolean;
}

/**
 * @generated from message viam.service.motion.v1.ListPlanStatusesRequest
 */
export declare class ListPlanStatusesRequest extends Message<ListPlanStatusesRequest> {
  /**
   * The name of the motion service
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * If supplied, the response will filter the
   * plan results for the supplied state
   *
   * @generated from field: bool only_active_plans = 2;
   */
  onlyActivePlans: boolean;

  /**
   * Additional arguments to the method
   *
   * @generated from field: google.protobuf.Struct extra = 99;
   */
  extra?: Struct;

  constructor(data?: PartialMessage<ListPlanStatusesRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.ListPlanStatusesRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListPlanStatusesRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListPlanStatusesRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListPlanStatusesRequest;

  static equals(a: ListPlanStatusesRequest | PlainMessage<ListPlanStatusesRequest> | undefined, b: ListPlanStatusesRequest | PlainMessage<ListPlanStatusesRequest> | undefined): boolean;
}

/**
 * Status of all executed / executing plan statuses with associated IDs within the 24 hour TTL
 *
 * @generated from message viam.service.motion.v1.ListPlanStatusesResponse
 */
export declare class ListPlanStatusesResponse extends Message<ListPlanStatusesResponse> {
  /**
   * List of last known statuses with the associated IDs of all plans within the TTL
   * ordered by timestamp in ascending order
   *
   * @generated from field: repeated viam.service.motion.v1.PlanStatusWithID plan_statuses_with_ids = 1;
   */
  planStatusesWithIds: PlanStatusWithID[];

  constructor(data?: PartialMessage<ListPlanStatusesResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.ListPlanStatusesResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListPlanStatusesResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListPlanStatusesResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListPlanStatusesResponse;

  static equals(a: ListPlanStatusesResponse | PlainMessage<ListPlanStatusesResponse> | undefined, b: ListPlanStatusesResponse | PlainMessage<ListPlanStatusesResponse> | undefined): boolean;
}

/**
 * @generated from message viam.service.motion.v1.GetPlanRequest
 */
export declare class GetPlanRequest extends Message<GetPlanRequest> {
  /**
   * The name of the motion service
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The name of the component which was requested to be moved.
   *
   * @generated from field: viam.common.v1.ResourceName component_name = 2;
   */
  componentName?: ResourceName;

  /**
   * If supplied, the response will only return
   * the the last plan for the component / execution
   *
   * @generated from field: bool last_plan_only = 3;
   */
  lastPlanOnly: boolean;

  /**
   * If you want to know about the plans of a previous execution
   *
   * @generated from field: optional string execution_id = 4;
   */
  executionId?: string;

  /**
   * Additional arguments to the method
   *
   * @generated from field: google.protobuf.Struct extra = 99;
   */
  extra?: Struct;

  constructor(data?: PartialMessage<GetPlanRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.GetPlanRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPlanRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPlanRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPlanRequest;

  static equals(a: GetPlanRequest | PlainMessage<GetPlanRequest> | undefined, b: GetPlanRequest | PlainMessage<GetPlanRequest> | undefined): boolean;
}

/**
 * @generated from message viam.service.motion.v1.GetPlanResponse
 */
export declare class GetPlanResponse extends Message<GetPlanResponse> {
  /**
   * The current plan and status that matches the request query
   *
   * @generated from field: viam.service.motion.v1.PlanWithStatus current_plan_with_status = 1;
   */
  currentPlanWithStatus?: PlanWithStatus;

  /**
   * Returns the history of all previous plans that were
   * generated in ascending order.
   * This field will be empty if the motion service
   * did not need to re-plan.
   *
   * @generated from field: repeated viam.service.motion.v1.PlanWithStatus replan_history = 2;
   */
  replanHistory: PlanWithStatus[];

  constructor(data?: PartialMessage<GetPlanResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.GetPlanResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPlanResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPlanResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPlanResponse;

  static equals(a: GetPlanResponse | PlainMessage<GetPlanResponse> | undefined, b: GetPlanResponse | PlainMessage<GetPlanResponse> | undefined): boolean;
}

/**
 * Constraints specifies all enumerated constraints to be passed to Viam's motion planning, along with any optional parameters
 *
 * @generated from message viam.service.motion.v1.Constraints
 */
export declare class Constraints extends Message<Constraints> {
  /**
   * Typed message for a specific constraint
   *
   * @generated from field: repeated viam.service.motion.v1.LinearConstraint linear_constraint = 1;
   */
  linearConstraint: LinearConstraint[];

  /**
   * @generated from field: repeated viam.service.motion.v1.OrientationConstraint orientation_constraint = 2;
   */
  orientationConstraint: OrientationConstraint[];

  /**
   * Arc constraint, Time constraint, and others will be added here when they are supported
   *
   * @generated from field: repeated viam.service.motion.v1.CollisionSpecification collision_specification = 3;
   */
  collisionSpecification: CollisionSpecification[];

  constructor(data?: PartialMessage<Constraints>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.Constraints";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Constraints;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Constraints;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Constraints;

  static equals(a: Constraints | PlainMessage<Constraints> | undefined, b: Constraints | PlainMessage<Constraints> | undefined): boolean;
}

/**
 * LinearConstraint specifies that the component being moved should move linearly relative to its goal.
 * It does not constrain the motion of components other than the `component_name` specified in motion.Move
 *
 * @generated from message viam.service.motion.v1.LinearConstraint
 */
export declare class LinearConstraint extends Message<LinearConstraint> {
  /**
   * Max linear deviation from straight-line between start and goal, in mm.
   *
   * @generated from field: optional float line_tolerance_mm = 1;
   */
  lineToleranceMm?: number;

  /**
   * Max allowable orientation deviation, in degrees, while on the shortest path between start / goal states
   *
   * @generated from field: optional float orientation_tolerance_degs = 2;
   */
  orientationToleranceDegs?: number;

  constructor(data?: PartialMessage<LinearConstraint>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.LinearConstraint";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LinearConstraint;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LinearConstraint;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LinearConstraint;

  static equals(a: LinearConstraint | PlainMessage<LinearConstraint> | undefined, b: LinearConstraint | PlainMessage<LinearConstraint> | undefined): boolean;
}

/**
 * OrientationConstraint specifies that the component being moved will not deviate its orientation beyond some threshold relative
 * to the goal. It does not constrain the motion of components other than the `component_name` specified in motion.Move
 *
 * @generated from message viam.service.motion.v1.OrientationConstraint
 */
export declare class OrientationConstraint extends Message<OrientationConstraint> {
  /**
   * Max allowable orientation deviation, in degrees, while on the shortest path between start / goal states
   *
   * @generated from field: optional float orientation_tolerance_degs = 1;
   */
  orientationToleranceDegs?: number;

  constructor(data?: PartialMessage<OrientationConstraint>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.OrientationConstraint";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrientationConstraint;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrientationConstraint;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrientationConstraint;

  static equals(a: OrientationConstraint | PlainMessage<OrientationConstraint> | undefined, b: OrientationConstraint | PlainMessage<OrientationConstraint> | undefined): boolean;
}

/**
 * CollisionSpecification is used to selectively apply obstacle avoidance to specific parts of the robot
 *
 * @generated from message viam.service.motion.v1.CollisionSpecification
 */
export declare class CollisionSpecification extends Message<CollisionSpecification> {
  /**
   * Pairs of frame which should be allowed to collide with one another
   *
   * @generated from field: repeated viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions allows = 1;
   */
  allows: CollisionSpecification_AllowedFrameCollisions[];

  constructor(data?: PartialMessage<CollisionSpecification>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.CollisionSpecification";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollisionSpecification;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollisionSpecification;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollisionSpecification;

  static equals(a: CollisionSpecification | PlainMessage<CollisionSpecification> | undefined, b: CollisionSpecification | PlainMessage<CollisionSpecification> | undefined): boolean;
}

/**
 * @generated from message viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions
 */
export declare class CollisionSpecification_AllowedFrameCollisions extends Message<CollisionSpecification_AllowedFrameCollisions> {
  /**
   * @generated from field: string frame1 = 1;
   */
  frame1: string;

  /**
   * @generated from field: string frame2 = 2;
   */
  frame2: string;

  constructor(data?: PartialMessage<CollisionSpecification_AllowedFrameCollisions>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.CollisionSpecification.AllowedFrameCollisions";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollisionSpecification_AllowedFrameCollisions;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollisionSpecification_AllowedFrameCollisions;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollisionSpecification_AllowedFrameCollisions;

  static equals(a: CollisionSpecification_AllowedFrameCollisions | PlainMessage<CollisionSpecification_AllowedFrameCollisions> | undefined, b: CollisionSpecification_AllowedFrameCollisions | PlainMessage<CollisionSpecification_AllowedFrameCollisions> | undefined): boolean;
}

/**
 * Describes a plan, its current status & all status changes
 * that have occured previously on that plan
 *
 * @generated from message viam.service.motion.v1.PlanWithStatus
 */
export declare class PlanWithStatus extends Message<PlanWithStatus> {
  /**
   * The plan
   *
   * @generated from field: viam.service.motion.v1.Plan plan = 1;
   */
  plan?: Plan;

  /**
   * The current status of the plan
   *
   * @generated from field: viam.service.motion.v1.PlanStatus status = 2;
   */
  status?: PlanStatus;

  /**
   * The prior status changes that have happened during plan execution
   *
   * @generated from field: repeated viam.service.motion.v1.PlanStatus status_history = 3;
   */
  statusHistory: PlanStatus[];

  constructor(data?: PartialMessage<PlanWithStatus>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.PlanWithStatus";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlanWithStatus;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlanWithStatus;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlanWithStatus;

  static equals(a: PlanWithStatus | PlainMessage<PlanWithStatus> | undefined, b: PlanWithStatus | PlainMessage<PlanWithStatus> | undefined): boolean;
}

/**
 * PlanStatusWithID describes the state of a given plan at a
 * point in time plus the plan_id, component_name and execution_id
 * the status is associated with
 *
 * @generated from message viam.service.motion.v1.PlanStatusWithID
 */
export declare class PlanStatusWithID extends Message<PlanStatusWithID> {
  /**
   * The unique ID of the plan
   *
   * @generated from field: string plan_id = 1;
   */
  planId: string;

  /**
   * The component to be moved.
   * Used for tracking & stopping.
   * NOTE: A plan may move more components than just the
   * component_name.
   *
   * @generated from field: viam.common.v1.ResourceName component_name = 2;
   */
  componentName?: ResourceName;

  /**
   * The unique ID which identifies the plan execution.
   * Multiple plans will share the same execution_id if they were
   * generated due to replanning.
   *
   * @generated from field: string execution_id = 3;
   */
  executionId: string;

  /**
   * @generated from field: viam.service.motion.v1.PlanStatus status = 4;
   */
  status?: PlanStatus;

  constructor(data?: PartialMessage<PlanStatusWithID>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.PlanStatusWithID";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlanStatusWithID;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlanStatusWithID;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlanStatusWithID;

  static equals(a: PlanStatusWithID | PlainMessage<PlanStatusWithID> | undefined, b: PlanStatusWithID | PlainMessage<PlanStatusWithID> | undefined): boolean;
}

/**
 * Plan status describes the state of a given plan at a
 * point in time
 *
 * @generated from message viam.service.motion.v1.PlanStatus
 */
export declare class PlanStatus extends Message<PlanStatus> {
  /**
   * The state of the plan execution
   *
   * @generated from field: viam.service.motion.v1.PlanState state = 1;
   */
  state: PlanState;

  /**
   * The time the executing plan transtioned to the state
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 2;
   */
  timestamp?: Timestamp;

  /**
   * The reason for the state change. If motion plan failed
   * this will return the error message.
   * If motion needed to re-plan, this will return
   * the re-plan reason.
   *
   * @generated from field: optional string reason = 3;
   */
  reason?: string;

  constructor(data?: PartialMessage<PlanStatus>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.PlanStatus";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlanStatus;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlanStatus;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlanStatus;

  static equals(a: PlanStatus | PlainMessage<PlanStatus> | undefined, b: PlanStatus | PlainMessage<PlanStatus> | undefined): boolean;
}

/**
 * A plan describes a motion plan
 *
 * @generated from message viam.service.motion.v1.Plan
 */
export declare class Plan extends Message<Plan> {
  /**
   * The plan's unique ID
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The component requested to be moved.
   * Used for tracking & stopping.
   * NOTE: A plan may move more components than just the
   * root component.
   *
   * @generated from field: viam.common.v1.ResourceName component_name = 2;
   */
  componentName?: ResourceName;

  /**
   * The unique ID which identifies the execution.
   * Multiple plans will share the same execution_id if they were
   * generated due to replanning
   *
   * @generated from field: string execution_id = 3;
   */
  executionId: string;

  /**
   * The steps of a plan is an ordered list of plan steps
   *
   * @generated from field: repeated viam.service.motion.v1.PlanStep steps = 4;
   */
  steps: PlanStep[];

  constructor(data?: PartialMessage<Plan>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.Plan";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Plan;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Plan;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Plan;

  static equals(a: Plan | PlainMessage<Plan> | undefined, b: Plan | PlainMessage<Plan> | undefined): boolean;
}

/**
 * @generated from message viam.service.motion.v1.PlanStep
 */
export declare class PlanStep extends Message<PlanStep> {
  /**
   * A step is the component state each
   * component resource should reach while executing
   * that step of the plan.
   * Keys are the fully qualified component name.
   *
   * @generated from field: map<string, viam.service.motion.v1.ComponentState> step = 1;
   */
  step: { [key: string]: ComponentState };

  constructor(data?: PartialMessage<PlanStep>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.PlanStep";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlanStep;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlanStep;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlanStep;

  static equals(a: PlanStep | PlainMessage<PlanStep> | undefined, b: PlanStep | PlainMessage<PlanStep> | undefined): boolean;
}

/**
 * A pose
 *
 * @generated from message viam.service.motion.v1.ComponentState
 */
export declare class ComponentState extends Message<ComponentState> {
  /**
   * @generated from field: viam.common.v1.Pose pose = 1;
   */
  pose?: Pose;

  constructor(data?: PartialMessage<ComponentState>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.motion.v1.ComponentState";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComponentState;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComponentState;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComponentState;

  static equals(a: ComponentState | PlainMessage<ComponentState> | undefined, b: ComponentState | PlainMessage<ComponentState> | undefined): boolean;
}

