// @generated by protoc-gen-es v1.10.0
// @generated from file service/slam/v1/slam.proto (package viam.service.slam.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { Pose } from "../../../common/v1/common_pb.js";

/**
 * MappingMode represnts the various form of mapping and localizing SLAM can perform.
 * These include, creating a new map, localizing on an existiing map and updating an
 * exisiting map.
 *
 * @generated from enum viam.service.slam.v1.MappingMode
 */
export declare enum MappingMode {
  /**
   * @generated from enum value: MAPPING_MODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: MAPPING_MODE_CREATE_NEW_MAP = 1;
   */
  CREATE_NEW_MAP = 1,

  /**
   * @generated from enum value: MAPPING_MODE_LOCALIZE_ONLY = 2;
   */
  LOCALIZE_ONLY = 2,

  /**
   * @generated from enum value: MAPPING_MODE_UPDATE_EXISTING_MAP = 3;
   */
  UPDATE_EXISTING_MAP = 3,
}

/**
 * @generated from enum viam.service.slam.v1.SensorType
 */
export declare enum SensorType {
  /**
   * @generated from enum value: SENSOR_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SENSOR_TYPE_CAMERA = 1;
   */
  CAMERA = 1,

  /**
   * @generated from enum value: SENSOR_TYPE_MOVEMENT_SENSOR = 2;
   */
  MOVEMENT_SENSOR = 2,
}

/**
 * @generated from message viam.service.slam.v1.GetPositionRequest
 */
export declare class GetPositionRequest extends Message<GetPositionRequest> {
  /**
   * Name of slam service
   *
   * @generated from field: string name = 1;
   */
  name: string;

  constructor(data?: PartialMessage<GetPositionRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.slam.v1.GetPositionRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPositionRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPositionRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPositionRequest;

  static equals(a: GetPositionRequest | PlainMessage<GetPositionRequest> | undefined, b: GetPositionRequest | PlainMessage<GetPositionRequest> | undefined): boolean;
}

/**
 * @generated from message viam.service.slam.v1.GetPositionResponse
 */
export declare class GetPositionResponse extends Message<GetPositionResponse> {
  /**
   * Current position of the specified component in the SLAM Map
   *
   * @generated from field: viam.common.v1.Pose pose = 1;
   */
  pose?: Pose;

  constructor(data?: PartialMessage<GetPositionResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.slam.v1.GetPositionResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPositionResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPositionResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPositionResponse;

  static equals(a: GetPositionResponse | PlainMessage<GetPositionResponse> | undefined, b: GetPositionResponse | PlainMessage<GetPositionResponse> | undefined): boolean;
}

/**
 * @generated from message viam.service.slam.v1.GetPointCloudMapRequest
 */
export declare class GetPointCloudMapRequest extends Message<GetPointCloudMapRequest> {
  /**
   * Name of slam service
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * For SLAM services that implement handling an edited map, this boolean
   * should indicate whether to return that edited map. If the SLAM service
   * does not handle edited maps, the unedited map will be returned instead.
   *
   * @generated from field: optional bool return_edited_map = 2;
   */
  returnEditedMap?: boolean;

  constructor(data?: PartialMessage<GetPointCloudMapRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.slam.v1.GetPointCloudMapRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPointCloudMapRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPointCloudMapRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPointCloudMapRequest;

  static equals(a: GetPointCloudMapRequest | PlainMessage<GetPointCloudMapRequest> | undefined, b: GetPointCloudMapRequest | PlainMessage<GetPointCloudMapRequest> | undefined): boolean;
}

/**
 * @generated from message viam.service.slam.v1.GetPointCloudMapResponse
 */
export declare class GetPointCloudMapResponse extends Message<GetPointCloudMapResponse> {
  /**
   * One chunk of the PointCloud.
   * For a given GetPointCloudMap request, concatenating all
   * GetPointCloudMapResponse.point_cloud_pcd_chunk values in the
   * order received result in the complete pointcloud in standard PCD
   * format where XY is the ground plane and positive Z is up, following
   * the Right Hand Rule.
   *
   * Read more about the pointcloud format here:
   * https://pointclouds.org/documentation/tutorials/pcd_file_format.html
   *
   * Viam expects pointcloud data with fields "x y z" or "x y z rgb", and for
   * this to be specified in the pointcloud header in the FIELDS entry. If color
   * data is included in the pointcloud, Viam's services assume that the color
   * value encodes a confidence score for that data point. Viam expects the
   * confidence score to be encoded in the blue parameter of the RGB value, on a
   * scale from 1-100.
   *
   * Pointclouds are little endian encoded.
   *
   * @generated from field: bytes point_cloud_pcd_chunk = 1;
   */
  pointCloudPcdChunk: Uint8Array;

  constructor(data?: PartialMessage<GetPointCloudMapResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.slam.v1.GetPointCloudMapResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPointCloudMapResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPointCloudMapResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPointCloudMapResponse;

  static equals(a: GetPointCloudMapResponse | PlainMessage<GetPointCloudMapResponse> | undefined, b: GetPointCloudMapResponse | PlainMessage<GetPointCloudMapResponse> | undefined): boolean;
}

/**
 * @generated from message viam.service.slam.v1.GetInternalStateRequest
 */
export declare class GetInternalStateRequest extends Message<GetInternalStateRequest> {
  /**
   * Name of slam service
   *
   * @generated from field: string name = 1;
   */
  name: string;

  constructor(data?: PartialMessage<GetInternalStateRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.slam.v1.GetInternalStateRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetInternalStateRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetInternalStateRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetInternalStateRequest;

  static equals(a: GetInternalStateRequest | PlainMessage<GetInternalStateRequest> | undefined, b: GetInternalStateRequest | PlainMessage<GetInternalStateRequest> | undefined): boolean;
}

/**
 * @generated from message viam.service.slam.v1.GetInternalStateResponse
 */
export declare class GetInternalStateResponse extends Message<GetInternalStateResponse> {
  /**
   * Chunk of the internal state of the SLAM algorithm required to continue
   * mapping/localization
   *
   * @generated from field: bytes internal_state_chunk = 1;
   */
  internalStateChunk: Uint8Array;

  constructor(data?: PartialMessage<GetInternalStateResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.slam.v1.GetInternalStateResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetInternalStateResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetInternalStateResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetInternalStateResponse;

  static equals(a: GetInternalStateResponse | PlainMessage<GetInternalStateResponse> | undefined, b: GetInternalStateResponse | PlainMessage<GetInternalStateResponse> | undefined): boolean;
}

/**
 * @generated from message viam.service.slam.v1.GetPropertiesRequest
 */
export declare class GetPropertiesRequest extends Message<GetPropertiesRequest> {
  /**
   * Name of the slam service
   *
   * @generated from field: string name = 1;
   */
  name: string;

  constructor(data?: PartialMessage<GetPropertiesRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.slam.v1.GetPropertiesRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPropertiesRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPropertiesRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPropertiesRequest;

  static equals(a: GetPropertiesRequest | PlainMessage<GetPropertiesRequest> | undefined, b: GetPropertiesRequest | PlainMessage<GetPropertiesRequest> | undefined): boolean;
}

/**
 * Returns properties information for the named slam service
 *
 * @generated from message viam.service.slam.v1.GetPropertiesResponse
 */
export declare class GetPropertiesResponse extends Message<GetPropertiesResponse> {
  /**
   * @generated from field: bool cloud_slam = 1;
   */
  cloudSlam: boolean;

  /**
   * @generated from field: viam.service.slam.v1.MappingMode mapping_mode = 2;
   */
  mappingMode: MappingMode;

  /**
   * @generated from field: optional string internal_state_file_type = 3;
   */
  internalStateFileType?: string;

  /**
   * @generated from field: repeated viam.service.slam.v1.SensorInfo sensor_info = 4;
   */
  sensorInfo: SensorInfo[];

  constructor(data?: PartialMessage<GetPropertiesResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.slam.v1.GetPropertiesResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPropertiesResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPropertiesResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPropertiesResponse;

  static equals(a: GetPropertiesResponse | PlainMessage<GetPropertiesResponse> | undefined, b: GetPropertiesResponse | PlainMessage<GetPropertiesResponse> | undefined): boolean;
}

/**
 * @generated from message viam.service.slam.v1.SensorInfo
 */
export declare class SensorInfo extends Message<SensorInfo> {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: viam.service.slam.v1.SensorType type = 2;
   */
  type: SensorType;

  constructor(data?: PartialMessage<SensorInfo>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "viam.service.slam.v1.SensorInfo";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SensorInfo;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SensorInfo;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SensorInfo;

  static equals(a: SensorInfo | PlainMessage<SensorInfo> | undefined, b: SensorInfo | PlainMessage<SensorInfo> | undefined): boolean;
}

