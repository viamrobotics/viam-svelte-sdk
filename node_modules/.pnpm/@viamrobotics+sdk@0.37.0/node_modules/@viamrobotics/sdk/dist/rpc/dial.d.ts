import type { Transport } from '@connectrpc/connect';
import { type Credentials } from '../app/viam-transport';
export interface DialOptions {
    credentials?: Credentials | undefined;
    webrtcOptions?: DialWebRTCOptions;
    externalAuthAddress?: string | undefined;
    externalAuthToEntity?: string | undefined;
    /**
     * `accessToken` allows a pre-authenticated client to dial with an
     * authorization header. Direct dial will have the access token appended to
     * the "Authorization: Bearer" header. WebRTC dial will appened it to the
     * signaling server communication
     *
     * If enabled, other auth options have no affect. Eg. authEntity, credentials,
     * externalAuthAddress, externalAuthToEntity,
     * webrtcOptions.signalingAccessToken
     */
    accessToken?: string | undefined;
    dialTimeout?: number | undefined;
    extraHeaders?: Headers;
}
export interface DialWebRTCOptions {
    disableTrickleICE: boolean;
    rtcConfig?: RTCConfiguration;
    /**
     * SignalingExternalAuthAddress is the address to perform external auth yet.
     * This is unlikely to be needed since the signaler is typically in the same
     * place where authentication happens.
     */
    signalingExternalAuthAddress?: string;
    /**
     * SignalingExternalAuthToEntity is the entity to authenticate for after
     * externally authenticating. This is unlikely to be needed since the signaler
     * is typically in the same place where authentication happens.
     */
    signalingExternalAuthToEntity?: string;
    signalingCredentials?: Credentials;
    /**
     * `signalingAccessToken` allows a pre-authenticated client to dial with an
     * authorization header to the signaling server. This skips the Authenticate()
     * request to the singaling server or external auth but does not skip the
     * AuthenticateTo() request to retrieve the credentials at the external auth
     * endpoint.
     *
     * If enabled, other auth options have no affect. Eg. authEntity, credentials,
     * signalingAuthEntity, signalingCredentials.
     */
    signalingAccessToken?: string;
    additionalSdpFields?: Record<string, string | number>;
}
export type TransportFactory = (init: TransportInitOptions) => Transport;
interface TransportInitOptions {
    baseUrl: string;
}
export declare const dialDirect: (address: string, opts?: DialOptions) => Promise<Transport>;
export declare const cloneHeaders: (headers: HeadersInit | undefined) => Headers;
export interface WebRTCConnection {
    transport: Transport;
    peerConnection: RTCPeerConnection;
    dataChannel: RTCDataChannel;
}
/**
 * DialWebRTC makes a connection to given host by signaling with the address
 * provided. A Promise is returned upon successful connection that contains a
 * transport factory to use with gRPC client as well as the WebRTC
 * PeerConnection itself. Care should be taken with the PeerConnection and is
 * currently returned for experimental use. TODO(GOUT-7): figure out decent way
 * to handle reconnect on connection termination
 */
export declare const dialWebRTC: (signalingAddress: string, host: string, dialOpts?: DialOptions) => Promise<WebRTCConnection>;
export {};
