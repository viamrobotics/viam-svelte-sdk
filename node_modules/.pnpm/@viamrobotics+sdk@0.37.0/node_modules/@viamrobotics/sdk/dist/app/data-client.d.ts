import { type JsonValue } from '@bufbuild/protobuf';
import { type Transport } from '@connectrpc/connect';
import { BinaryID, CaptureMetadata, Filter, Order } from '../gen/app/data/v1/data_pb';
import type { Dataset as PBDataset } from '../gen/app/dataset/v1/dataset_pb';
export type FilterOptions = Partial<Filter> & {
    endTime?: Date;
    startTime?: Date;
    tags?: string[];
};
interface TabularData {
    data?: JsonValue;
    metadata?: CaptureMetadata;
    timeRequested?: Date;
    timeReceived?: Date;
}
interface TabularDataPoint {
    partId: string;
    resourceName: string;
    resourceSubtype: string;
    methodName: string;
    timeCaptured: Date;
    organizationId: string;
    locationId: string;
    robotName: string;
    robotId: string;
    partName: string;
    methodParameters: JsonValue;
    tags: string[];
    payload: JsonValue;
}
export type Dataset = Partial<PBDataset> & {
    created?: Date;
};
export declare class DataClient {
    private dataClient;
    private datasetClient;
    private dataSyncClient;
    constructor(transport: Transport);
    /**
     * Obtain unified tabular data and metadata from the specified data source.
     *
     * @param partId The ID of the part that owns the data
     * @param resourceName The name of the requested resource that captured the
     *   data
     * @param resourceSubtype The subtype of the requested resource that captured
     *   the data
     * @param methodName The data capture method name
     * @param startTime Optional start time (`Date` object) for requesting a
     *   specific range of data
     * @param endTime Optional end time (`Date` object) for requesting a specific
     *   range of data
     * @returns An array of unified tabular data and metadata.
     */
    exportTabularData(partId: string, resourceName: string, resourceSubtype: string, methodName: string, startTime?: Date, endTime?: Date): Promise<TabularDataPoint[]>;
    /**
     * Obtain unified tabular data and metadata, queried with SQL.
     *
     * @param organizationId The ID of the organization that owns the data
     * @param query The SQL query to run
     * @returns An array of data objects
     */
    tabularDataBySQL(organizationId: string, query: string): Promise<(Object | any[])[]>;
    /**
     * Obtain unified tabular data and metadata, queried with MQL.
     *
     * @param organizationId The ID of the organization that owns the data
     * @param query The MQL query to run as a list of BSON documents
     * @param useRecentData Whether to query blob storage or your recent data
     *   store. Defaults to false
     * @returns An array of data objects
     */
    tabularDataByMQL(organizationId: string, query: Uint8Array[] | Record<string, Date | JsonValue>[], useRecentData?: boolean): Promise<(Object | any[])[]>;
    /**
     * Filter and get a page of tabular data. The returned metadata might be empty
     * if the metadata index of the data is out of the bounds of the returned
     * metadata list. The data will be paginated into pages of `limit` items, and
     * the pagination ID will be included in the returned tuple.
     *
     * @param filter Optional `pb.Filter` specifying tabular data to retrieve. No
     *   `filter` implies all tabular data.
     * @param limit The maximum number of entries to include in a page. Defaults
     *   to 50 if unspecfied
     * @param sortOrder The desired sort order of the data
     * @param last Optional string indicating the ID of the last-returned data. If
     *   provided, the server will return the next data entries after the `last`
     *   ID.
     * @param countOnly Whether to return only the total count of entries
     * @param includeInternalData Whether to retun internal data. Internal data is
     *   used for Viam-specific data ingestion, like cloud SLAM. Defaults to
     *   `false`.
     * @returns An array of data objects, the count (number of entries), and the
     *   last-returned page ID.
     */
    tabularDataByFilter(filter?: Filter, limit?: number, sortOrder?: Order, last?: string, countOnly?: boolean, includeInternalData?: boolean): Promise<{
        data: TabularData[];
        count: bigint;
        last: string;
    }>;
    /**
     * Filter and get a page of binary data. The returned metadata might be empty
     * if the metadata index of the data is out of the bounds of the returned
     * metadata list. The data will be paginated into pages of `limit` items, and
     * the pagination ID will be included in the returned tuple.
     *
     * @param filter Optional `pb.Filter` specifying binary data to retrieve. No
     *   `filter` implies all binary data.
     * @param limit The maximum number of entries to include in a page. Defaults
     *   to 50 if unspecfied
     * @param sortOrder The desired sort order of the data
     * @param last Optional string indicating the ID of the last-returned data. If
     *   provided, the server will return the next data entries after the `last`
     *   ID.
     * @param includeBinary Whether to include binary file data with each
     *   retrieved file
     * @param countOnly Whether to return only the total count of entries
     * @param includeInternalData Whether to retun internal data. Internal data is
     *   used for Viam-specific data ingestion, like cloud SLAM. Defaults to
     *   `false`.
     * @returns An array of data objects, the count (number of entries), and the
     *   last-returned page ID.
     */
    binaryDataByFilter(filter?: Filter, limit?: number, sortOrder?: Order, last?: string, includeBinary?: boolean, countOnly?: boolean, includeInternalData?: boolean): Promise<{
        data: import("../gen/app/data/v1/data_pb").BinaryData[];
        count: bigint;
        last: string;
    }>;
    /**
     * Get binary data using the BinaryID.
     *
     * @param ids The IDs of the requested binary data
     * @returns An array of data objects
     */
    binaryDataByIds(ids: BinaryID[]): Promise<import("../gen/app/data/v1/data_pb").BinaryData[]>;
    /**
     * Delete tabular data older than a specified number of days.
     *
     * @param organizationId The ID of organization to delete data from
     * @param deleteOlderThanDays Delete data that was captured more than this
     *   many days ago. For example if `deleteOlderThanDays` is 10, this deletes
     *   any data that was captured more than 10 days ago. If it is 0, all
     *   existing data is deleted.
     * @returns The number of items deleted
     */
    deleteTabularData(organizationId: string, deleteOlderThanDays: number): Promise<bigint>;
    /**
     * Filter and delete binary data.
     *
     * @param filter Optional `pb.Filter` specifying binary data to delete. No
     *   `filter` implies all binary data.
     * @param includeInternalData Whether or not to delete internal data. Default
     *   is true
     * @returns The number of items deleted
     */
    deleteBinaryDataByFilter(filter?: Filter, includeInternalData?: boolean): Promise<bigint>;
    /**
     * Delete binary data, specified by ID.
     *
     * @param ids The IDs of the data to be deleted. Must be non-empty.
     * @returns The number of items deleted
     */
    deleteBinaryDataByIds(ids: BinaryID[]): Promise<bigint>;
    /**
     * Add tags to binary data, specified by ID.
     *
     * @param tags The list of tags to add to specified binary data. Must be
     *   non-empty.
     * @param ids The IDs of the data to be tagged. Must be non-empty.
     */
    addTagsToBinaryDataByIds(tags: string[], ids: BinaryID[]): Promise<void>;
    /**
     * Add tags to binary data, specified by filter.
     *
     * @param tags The tags to add to the data
     * @param filter Optional `pb.Filter` specifying binary data to add tags to.
     *   No `filter` implies all binary data.
     */
    addTagsToBinaryDataByFilter(tags: string[], filter?: Filter): Promise<void>;
    /**
     * Remove tags from binary data, specified by ID.
     *
     * @param tags List of tags to remove from specified binary data. Must be
     *   non-empty.
     * @param ids The IDs of the data to be edited. Must be non-empty.
     * @returns The number of items deleted
     */
    removeTagsFromBinaryDataByIds(tags: string[], ids: BinaryID[]): Promise<bigint>;
    /**
     * Remove tags from binary data, specified by filter.
     *
     * @param tags List of tags to remove from specified binary data. Must be
     *   non-empty.
     * @param filter Optional `pb.Filter` specifying binary data to add tags to.
     *   No `filter` implies all binary data.
     * @returns The number of items deleted
     */
    removeTagsFromBinaryDataByFilter(tags: string[], filter?: Filter): Promise<bigint>;
    /**
     * Get a list of tags using a filter.
     *
     * @param filter Optional `pb.Filter` specifying what data to get tags from.
     *   No `filter` implies all data.
     * @returns The list of tags
     */
    tagsByFilter(filter?: Filter): Promise<string[]>;
    /**
     * Add bounding box to an image.
     *
     * @param binaryId The ID of the image to add the bounding box to
     * @param label A label for the bounding box
     * @param xMinNormalized The min X value of the bounding box normalized from 0
     *   to 1
     * @param yMinNormalized The min Y value of the bounding box normalized from 0
     *   to 1
     * @param xMaxNormalized The max X value of the bounding box normalized from 0
     *   to 1
     * @param yMaxNormalized The max Y value of the bounding box normalized from 0
     *   to 1
     * @returns The bounding box ID
     */
    addBoundingBoxToImageById(id: BinaryID, label: string, xMinNormalized: number, yMinNormalized: number, xMaxNormalized: number, yMaxNormalized: number): Promise<string>;
    /**
     * Remove a bounding box from an image.
     *
     * @param binId The ID of the image to remove the bounding box from
     * @param bboxId The ID of the bounding box to remove
     */
    removeBoundingBoxFromImageById(binId: BinaryID, bboxId: string): Promise<void>;
    /**
     * Get a list of bounding box labels using a Filter.
     *
     * @param filter Optional `pb.Filter` specifying what data to get tags from.
     *   No `filter` implies all labels.
     * @returns The list of bounding box labels
     */
    boundingBoxLabelsByFilter(filter?: Filter): Promise<string[]>;
    /**
     * Configure a database user for the Viam organization's MongoDB Atlas Data
     * Federation instance. It can also be used to reset the password of the
     * existing database user.
     *
     * @param organizationId The ID of the organization
     * @param password The password of the user
     */
    configureDatabaseUser(organizationId: string, password: string): Promise<void>;
    /**
     * Get a connection to access a MongoDB Atlas Data federation instance.
     *
     * @param organizationId Organization to retrieve connection for
     * @returns Hostname of the federated database
     */
    getDatabaseConnection(organizationId: string): Promise<string>;
    /**
     * Add BinaryData to the provided dataset.
     *
     * @param ids The IDs of binary data to add to dataset
     * @param datasetId The ID of the dataset to be added to
     */
    addBinaryDataToDatasetByIds(ids: BinaryID[], datasetId: string): Promise<void>;
    /**
     * Remove BinaryData from the provided dataset.
     *
     * @param ids The IDs of the binary data to remove from dataset
     * @param datasetId The ID of the dataset to be removed from
     */
    removeBinaryDataFromDatasetByIds(ids: BinaryID[], datasetId: string): Promise<void>;
    /**
     * Create a new dataset.
     *
     * @param name The name of the new dataset
     * @param organizationId The ID of the organization the dataset is being
     *   created in
     * @returns The ID of the dataset
     */
    createDataset(name: string, organizationId: string): Promise<string>;
    /**
     * Delete a dataset.
     *
     * @param id The ID of the dataset.
     */
    deleteDataset(id: string): Promise<void>;
    /**
     * Rename a dataset.
     *
     * @param id The ID of the dataset
     * @param name The new name of the dataset
     */
    renameDataset(id: string, name: string): Promise<void>;
    /**
     * List all of the datasets for an organization.
     *
     * @param organizationId The ID of the organization
     * @returns The list of datasets in the organization
     */
    listDatasetsByOrganizationID(organizationId: string): Promise<Dataset[]>;
    /**
     * List all of the datasets specified by the given dataset IDs.
     *
     * @param ids The list of IDs of the datasets
     * @returns The list of datasets
     */
    listDatasetsByIds(ids: string[]): Promise<Dataset[]>;
    /**
     * Uploads the content and metadata for tabular data.
     *
     * Upload tabular data collected on a robot through a specific component
     * (e.g., a motor) along with the relevant metadata to app.viam.com. Tabular
     * data can be found under the "Sensors" subtab of the Data tab on
     * app.viam.com.
     *
     * @param tabularData The list of data to be uploaded, represented tabularly
     *   as an array.
     * @param partId The part ID of the component used to capture the data
     * @param componentType The type of the component used to capture the data
     *   (e.g., "movementSensor")
     * @param componentName The name of the component used to capture the data
     * @param methodName The name of the method used to capture the data.
     * @param tags The list of tags to allow for tag-based filtering when
     *   retrieving data
     * @param dataRequestTimes Array of Date tuples, each containing two `Date`
     *   objects denoting the times this data was requested[0] by the robot and
     *   received[1] from the appropriate sensor. Passing a list of tabular data
     *   and Timestamps with length n > 1 will result in n datapoints being
     *   uploaded, all tied to the same metadata.
     * @returns The file ID of the uploaded data
     */
    tabularDataCaptureUpload(tabularData: Record<string, JsonValue>[], partId: string, componentType: string, componentName: string, methodName: string, dataRequestTimes: [Date, Date][], tags?: string[]): Promise<string>;
    /**
     * Uploads the content and metadata for binary data.
     *
     * Upload binary data collected on a robot through a specific component (e.g.,
     * a motor) along with the relevant metadata to app.viam.com. binary data can
     * be found under the "Sensors" subtab of the Data tab on app.viam.com.
     *
     * @param binaryData The data to be uploaded, represented in bytes
     * @param partId The part ID of the component used to capture the data
     * @param componentType The type of the component used to capture the data
     *   (e.g., "movementSensor")
     * @param componentName The name of the component used to capture the data
     * @param methodName The name of the method used to capture the data.
     * @param fileExtension The file extension of binary data including the
     *   period, e.g. .jpg, .png, .pcd. The backend will route the binary to its
     *   corresponding mime type based on this extension. Files with a .jpeg,
     *   .jpg, or .png extension will be saved to the images tab.
     * @param tags The list of tags to allow for tag-based filtering when
     *   retrieving data
     * @param dataRequestTimes Tuple containing `Date` objects denoting the times
     *   this data was requested[0] by the robot and received[1] from the
     *   appropriate sensor.
     * @returns The file ID of the uploaded data
     */
    binaryDataCaptureUpload(binaryData: Uint8Array, partId: string, componentType: string, componentName: string, methodName: string, fileExtension: string, dataRequestTimes: [Date, Date], tags?: string[]): Promise<string>;
    createFilter(options: FilterOptions): Filter;
    /**
     * Gets the most recent tabular data captured from the specified data source,
     * as long as it was synced within the last year.
     *
     * @param partId The ID of the part that owns the data
     * @param resourceName The name of the requested resource that captured the
     *   data. Ex: "my-sensor"
     * @param resourceSubtype The subtype of the requested resource that captured
     *   the data. Ex: "rdk:component:sensor"
     * @param methodName The data capture method name. Ex: "Readings"
     * @returns A tuple containing [timeCaptured, timeSynced, payload] or null if
     *   no data has been synced for the specified resource OR the most recently
     *   captured data was over a year ago
     */
    getLatestTabularData(partId: string, resourceName: string, resourceSubtype: string, methodName: string): Promise<[Date, Date, Record<string, JsonValue>] | null>;
}
export { type BinaryID, type Order } from '../gen/app/data/v1/data_pb';
export { type UploadMetadata } from '../gen/app/datasync/v1/data_sync_pb';
